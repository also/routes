package com.ryanberdeen.routes;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/** Matches and extracts parameters from paths.
 * @author Ryan Berdeen
 *
 */
public class PathPattern {
	private static final char[] PATTERN_SPECIAL_CHARS = ".\\+*?[^]$(){}=!<>|:".toCharArray();
	private static final String VALUE_WITHOUT_SLASHES = "[^/]+";
	private static final String VALUE_WITH_SLASHES = ".+";

	/** The regular expression this pattern uses to test paths. */
	private Pattern regex;

	/** The parameter names this pattern will provide. */
	private Set<String> parameterNames;

	/** The path segments that make up this pattern.
	 *  These segments are used to generate the regular expression and generate
	 *  paths from parameters.
	 */
	private List<PathSegment> pathSegments;

	public PathPattern(List<PathSegment> pathSegments, Set<String> parameterNames) {
		this.pathSegments = pathSegments;
		this.parameterNames = parameterNames;
	}

	private static boolean isPatternSpecialChar(char c) {
		for (char special : PATTERN_SPECIAL_CHARS) {
			if (c == special) {
					return true;
			}
		}

		return false;
	}

	private static void appendStringToRegex(String string, StringBuilder regexBuilder) {
		for (int i = 0, len = string.length(); i < len; i++) {
			char c = string.charAt(i);
			if (isPatternSpecialChar(c)) {
				regexBuilder.append('\\');
			}
			if (c == '/' && i == len - 1) {
				regexBuilder.append("(?:");
				regexBuilder.append(c);
				regexBuilder.append("|$)");
			}
			else {
				regexBuilder.append(c);
			}
		}
	}

	/** Returns the set of parameter names included in the path.
	 */
	public Set<String> getParameterNames() {
		return parameterNames;
	}

	public List<PathSegment> getPathSegments() {
		return pathSegments;
	}

	/** Lazily create the regular expression.
	 */
	public Pattern getRegex() {
		if (regex == null) {
			StringBuilder regexBuilder = new StringBuilder();
			regexBuilder.append('^');

			for (PathSegment segment : pathSegments) {
				segment.appendRegex(regexBuilder);
			}

			regexBuilder.append('$');
			regex = Pattern.compile(regexBuilder.toString());
		}

		return regex;
	}

	/** Matches the pattern against the path. If the path matches, a map of parameter
	 * values is returned. <code>null</code> indicates no match.
	 * @param path the path to test
	 * @return the parameters extracted from the path if it matches, <code>null</code> otherwise
	 */
	public Map<String, String> match(String path) {
		HashMap<String, String> result = null;
		Matcher matcher = getRegex().matcher(path);
		if (matcher.matches()) {
			result = new HashMap<String, String>();

			int matchNumber = 1;
			for (PathSegment segment : pathSegments) {
				if (segment instanceof ParameterSegment) {
					ParameterSegment parameter = (ParameterSegment) segment;
					String value = matcher.group(matchNumber++);

					if (!value.equals("")) {
						result.put(parameter.name, value);
					}
				}
			}
		}

		return result;
	}

	/** Builds a path using the parameters.
	 */
	public String buildPath(Map<String, Object> parameters, Map<String, String> staticParameterValues, Map<String, String> contextParameters) {
		PathBuilder pathBuilder = new PathBuilder();
		for (PathSegment segment : pathSegments) {
			segment.appendPath(pathBuilder, parameters, staticParameterValues, contextParameters);
		}

		return pathBuilder.toString();
	}

	/** Creates a template for substituting parameters. Parameters are represented
	 * as <code>${parameterName}</code>, similar to JSP EL.
	 */
	public String getStringTemplate() {
		StringBuilder templateBuilder = new StringBuilder();
		for (PathSegment segment : pathSegments) {
			segment.appendTemplate(templateBuilder);
		}

		return templateBuilder.toString();
	}

	public static interface PathSegment {
		/** Appends the regex that represents this segment to the builder.
		 */
		public void appendRegex(StringBuilder regexBuilder);

		/** Appends the path generated by applying the parameters to this segment to the builder.
		 */
		public void appendPath(PathBuilder pathBuilder, Map<String, Object> parameters, Map<String, String> staticParameters, Map<String, String> contextParameters);

		/** Appends the template that represents this segment to the builder.
		 */
		public void appendTemplate(StringBuilder templateBuilder);
	}

	public static class StaticSegment implements PathSegment, Cloneable {
		private String value;
		private boolean required;

		public StaticSegment(String value, boolean required) {
			this.value = value;
			this.required = required;
		}

		public void appendRegex(StringBuilder regexBuilder) {
			if (!required) {
				regexBuilder.append("(?:");
			}
			appendStringToRegex(value, regexBuilder);
			if (!required) {
				regexBuilder.append("|$)");
			}
		}

		public void appendPath(PathBuilder pathBuilder, Map<String, Object> parameters, Map<String, String> staticParameterValues, Map<String, String> contextParameters) {
			pathBuilder.append(value, required);
		}

		public void appendTemplate(StringBuilder templateBuilder) {
			templateBuilder.append(value);
		}
	}

	public static class ParameterSegment implements PathSegment, Cloneable {
		private boolean required;
		private boolean allowSlashes;
		private String name;
		private String regex;

		public ParameterSegment(boolean required, boolean allowSlashes, String name) {
			this(required, allowSlashes, name, null);
		}

		public ParameterSegment(boolean required, boolean allowSlashes, String name, String regex) {
			this.required = required;
			this.allowSlashes = allowSlashes;
			this.name = name;
			this.regex = regex;
		}

		public String getName() {
			return name;
		}

		public void appendRegex(StringBuilder regexBuilder) {
			regexBuilder.append('(');
			if (regex != null) {
				regexBuilder.append(regex);
			}
			else {
				regexBuilder.append(allowSlashes ? VALUE_WITH_SLASHES : VALUE_WITHOUT_SLASHES);
			}
			if (!required) {
				regexBuilder.append("|$");
			}
			regexBuilder.append(')');
		}

		public void appendPath(PathBuilder pathBuilder, Map<String, Object> parameters, Map<String, String> staticParameterValues, Map<String, String> contextParameters) {
			Object result = parameters.get(name);
			if (result == null) {
				result = staticParameterValues.get(name);
				if (result == null) {
					String contextValue = contextParameters.get(name);
					if (contextValue != null) {
						result = contextValue;
					}
				}
			}

			if (result == null) {
				throw new RuntimeException("No value for [" + name + "]");
			}
			pathBuilder.append(result, required || !result.equals(staticParameterValues.get(name)));
		}

		public void appendTemplate(StringBuilder templateBuilder) {
			templateBuilder.append("${");
			templateBuilder.append(name);
			templateBuilder.append("}");
		}
	}

	private static class PathBuilder {
		private int requiredLength = 0;
		private StringBuilder stringBuilder = new StringBuilder();

		public void append(Object o, boolean required) {
			String string = o.toString();
			stringBuilder.append(string);
			if (required) {
				requiredLength += string.length();
			}
		}

		@Override
		public String toString() {
			return stringBuilder.toString().substring(0, requiredLength);
		}
	}
}
